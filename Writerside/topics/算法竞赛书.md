# &#31639;&#27861;&#31454;&#36187;&#20070;

## 动态规划的概念
解决具有重叠子问题、最优子结构特征的问题
### 例：斐波那契数列
```tex
fib(n) = fib(n-1)+fib(n-2)
```
可以描述成走楼梯问题，一次走一步或者两步，到第n个台阶有多少种走法
```C++
int fib(int n){
    if( n==1 || n==2 ){
        return n = 1;
    }
    return fib(n-1)+fib(n-2);
}
```
上述代码的时间复杂度是O(2^n),n层的递归树

### 重叠子问题
画出递归树，可以发现有些子节点计算了多次，如计算fib(5)时，fib(3)计算了2次，通过分析得到最优子结构，然后通过递推或者带记忆的搜索进行编程
### 最优子结构
大问题的最优解包含小问题的最优解，小问题的最优解推导出大问题的最优解
+ 无后效性

## 动态规划编程的两种方法
### 自顶向下与记忆化
存储已经解决的子问题的问过的方法称之为记忆化
```C++
int memoize(N);
int fib(int n){
    if(n==1 || n==2) return 1;
    if(memoize[n] != 0) return memoize[n];
    else return mmemoize[n-1] +memoize[n-2];   
    return memoize[n]
}
```

### 自底向上与制表递推
```c++
int dp[N]
int fib(int n){
    dp[1] = 1;
    dp[2] = 1;
    for(int i=0;i<=n;i++){
        dp[i] = dp[i-1]+dp[i-2];
    }
    return dp[n];
}
```
以上两种方法的时间复杂度都为O(n)



